import { useState, useCallback, useEffect } from 'react';
import { AgentManager } from './components/AgentManager';
import { ChangeList } from './components/ChangeList';
import { AgentStartForm } from './components/AgentStartForm';
import { EditPermissionModal } from './components/EditPermissionModal';
import { useWebSocket } from './hooks/useWebSocket';
import { useAgents } from './hooks/useAgents';
import { useChanges } from './hooks/useChanges';
import { useIndexedDB } from './hooks/useIndexedDB';
import { WSMessage, StartAgentRequest, EditPermissionRequest } from './types';
import { apiClient } from './api/client';

function App() {
  const [activeTab, setActiveTab] = useState<'agents' | 'changes'>('agents');
  const [agentOutputs, setAgentOutputs] = useState<Map<string, string[]>>(new Map());
  const [commandOutputs, setCommandOutputs] = useState<Map<string, { output: string; status: string }>>(new Map());
  const [editPermissionRequest, setEditPermissionRequest] = useState<EditPermissionRequest | null>(null);

  const { agents, startAgent, stopAgent, addAgent, removeAgent, updateAgent } = useAgents();
  const { changes, addChange, updateChangeStatus, acceptChange, declineChange, sendInstruction } = useChanges();
  const { saveSession, updateSessionStatus, saveOutputLog, saveChange, getAllSessions, getOutputLogs } = useIndexedDB();
  const [isRestoring, setIsRestoring] = useState(true);

  const handleWebSocketMessage = useCallback((message: WSMessage) => {
    console.log('WebSocket message:', message);

    switch (message.type) {
      case 'agent_started':
        addAgent(message.data);
        // Save session to IndexedDB
        saveSession({
          id: message.data.sessionId,
          agentName: message.data.name,
          role: message.data.role,
          workDir: message.data.workDir,
          patterns: message.data.patterns,
          startedAt: message.data.startedAt,
          status: 'running',
          conversationHistory: [],
          outputLogs: [],
          changes: [],
        });
        break;

      case 'agent_stopped':
        updateAgent(message.data.agentId, { status: 'stopped' });
        updateSessionStatus(message.data.sessionId, 'stopped', Date.now());
        break;

      case 'new_change':
        addChange(message.data);
        saveChange(message.data);
        break;

      case 'status_update':
        updateChangeStatus(message.data.changeId, message.data.status);
        break;

      case 'agent_output':
        setAgentOutputs(prev => {
          const newMap = new Map(prev);
          const outputs = newMap.get(message.data.agentId) || [];
          newMap.set(message.data.agentId, [...outputs, message.data.output]);
          return newMap;
        });
        // Save to IndexedDB
        saveOutputLog(message.data.sessionId, {
          timestamp: message.data.timestamp,
          output: message.data.output,
          type: 'stdout',
        });
        break;

      case 'command_output':
        setCommandOutputs(prev => {
          const newMap = new Map(prev);
          const current = newMap.get(message.data.commandId) || { output: '', status: '' };
          newMap.set(message.data.commandId, {
            output: current.output + message.data.output,
            status: message.data.status,
          });
          return newMap;
        });
        break;

      case 'command_completed':
        setCommandOutputs(prev => {
          const newMap = new Map(prev);
          const current = newMap.get(message.data.commandId) || { output: '', status: '' };
          newMap.set(message.data.commandId, {
            ...current,
            status: message.data.status,
          });
          return newMap;
        });
        break;

      case 'edit_permission_request':
        console.log('Edit permission request received:', message.data);
        setEditPermissionRequest(message.data);
        break;
    }
  }, [addAgent, removeAgent, addChange, updateChangeStatus, saveSession, updateSessionStatus, saveOutputLog, saveChange]);

  const { isConnected } = useWebSocket(handleWebSocketMessage);

  // Restore data from IndexedDB on initial page load
  useEffect(() => {
    const restoreFromIndexedDB = async () => {
      try {
        console.log('[App] Restoring data from IndexedDB...');

        // Restore sessions and their output logs
        const sessions = await getAllSessions();
        console.log(`[App] Found ${sessions.length} sessions in IndexedDB`);

        for (const session of sessions) {
          // Only restore running sessions
          if (session.status === 'running') {
            console.log(`[App] Restoring session ${session.id} for agent ${session.agentName}`);

            // Load output logs for this session
            const logs = await getOutputLogs(session.id);
            console.log(`[App] Found ${logs.length} output logs for session ${session.id}`);

            // Find the agent ID from the current agents list (from server)
            const agent = agents.find(a => a.sessionId === session.id);
            if (agent) {
              // Restore outputs to state
              const outputs = logs.map(log => log.output);
              setAgentOutputs(prev => {
                const newMap = new Map(prev);
                newMap.set(agent.id, outputs);
                return newMap;
              });
              console.log(`[App] Restored ${outputs.length} outputs for agent ${agent.id}`);
            }
          }
        }

        console.log('[App] Data restoration complete');
      } catch (error) {
        console.error('[App] Failed to restore data from IndexedDB:', error);
      } finally {
        setIsRestoring(false);
      }
    };

    // Only restore if we have agents loaded from server
    if (agents.length > 0 && isRestoring) {
      restoreFromIndexedDB();
    } else if (agents.length === 0) {
      // No agents to restore
      setIsRestoring(false);
    }
  }, [agents, getAllSessions, getOutputLogs, isRestoring]);

  // Load agent outputs on initial mount only (not when agents change)
  useEffect(() => {
    agents.forEach(agent => {
      // Only load if we don't have outputs for this agent yet
      setAgentOutputs(prev => {
        // Skip if already loaded
        if (prev.has(agent.id)) {
          return prev;
        }

        // Load from API
        apiClient.getAgentOutput(agent.id)
          .then(outputResponse => {
            if (outputResponse.output && outputResponse.output.length > 0) {
              setAgentOutputs(current => {
                const newMap = new Map(current);
                newMap.set(agent.id, outputResponse.output);
                return newMap;
              });
            }
          })
          .catch(err => console.error(`Failed to load output for agent ${agent.id}:`, err));

        return prev;
      });
    });
  }, [agents]);

  // Load existing changes on startup
  useEffect(() => {
    const loadExistingChanges = async () => {
      try {
        const response = await apiClient.getChanges();
        console.log('Loaded existing changes:', response.changes);
        response.changes.forEach((change: any) => {
          addChange(change);
        });
      } catch (error) {
        console.error('Failed to load existing changes:', error);
      }
    };

    loadExistingChanges();
  }, [addChange]);

  const handleStartAgent = useCallback(async (data: StartAgentRequest) => {
    try {
      await startAgent(data);
    } catch (error) {
      console.error('Failed to start agent:', error);
    }
  }, [startAgent]);

  const handleStopAgent = useCallback(async (agentId: string) => {
    try {
      await stopAgent(agentId);
    } catch (error) {
      console.error('Failed to stop agent:', error);
    }
  }, [stopAgent]);

  const handleRestartAgent = useCallback(async (agentId: string) => {
    try {
      const agent = agents.find(a => a.id === agentId);
      if (!agent) {
        console.error('Agent not found:', agentId);
        return;
      }

      // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åœæ­¢ã—ã¦ã‹ã‚‰åŒã˜è¨­å®šã§å†èµ·å‹•
      const agentConfig = {
        name: agent.name,
        role: agent.role,
        workDir: agent.workDir,
        patterns: agent.patterns,
        // æ–°ã—ã„sessionIdã§èµ·å‹•ï¼ˆå¤ã„sessionIdã¯ä½¿ã‚ãªã„ï¼‰
      };

      // å¤ã„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰èµ·å‹•
      try {
        await removeAgent(agentId);
      } catch (err) {
        console.log('Failed to delete old agent (may not exist on server):', err);
      }

      // åŒã˜è¨­å®šã§æ–°ã—ã„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’èµ·å‹•
      await startAgent(agentConfig);
    } catch (error) {
      console.error('Failed to restart agent:', error);
    }
  }, [agents, startAgent, removeAgent]);

  const handleDeleteAgent = useCallback(async (agentId: string) => {
    try {
      const agent = agents.find(a => a.id === agentId);
      if (!agent) {
        console.error('Agent not found:', agentId);
        return;
      }

      // ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
      if (!confirm(`ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã€Œ${agent.name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
        return;
      }

      // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å‰Šé™¤
      removeAgent(agentId);
    } catch (error) {
      console.error('Failed to delete agent:', error);
    }
  }, [agents, removeAgent]);

  const handleExecuteCommand = useCallback((agentId: string, command: string) => {
    // This would be implemented with the API client
    console.log('Execute command:', agentId, command);
  }, []);

  const handleSendMessage = useCallback(async (agentId: string, message: string) => {
    try {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡ºåŠ›ã«è¿½åŠ ï¼ˆãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ä»˜ãï¼‰
      setAgentOutputs(prev => {
        const newMap = new Map(prev);
        const outputs = newMap.get(agentId) || [];
        newMap.set(agentId, [...outputs, `USER: ${message}`]);
        return newMap;
      });

      // APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ä½¿ã£ã¦ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
      await apiClient.sendMessageToAgent(agentId, message);
      console.log('Message sent to agent:', agentId, message);
    } catch (error) {
      console.error('Failed to send message:', error);
      alert('ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }, []);

  return (
    <div className="h-screen flex flex-col bg-gray-100">
      {/* å›ºå®šãƒ˜ãƒƒãƒ€ãƒ¼ */}
      <header className="bg-blue-600 text-white p-3 shadow-lg flex-shrink-0">
        <div className="flex items-center justify-between gap-4">
          <div className="flex items-center gap-4">
            <h1 className="text-xl font-bold whitespace-nowrap">ğŸ¤– Multi-Agent Dashboard</h1>
            <div className="text-xs whitespace-nowrap">
              WebSocket: {isConnected ? 'ğŸŸ¢ Connected' : 'ğŸ”´ Disconnected'}
            </div>
          </div>
          <div className="flex-1 min-w-0">
            <AgentStartForm onStartAgent={handleStartAgent} />
          </div>
        </div>
      </header>

      {/* å›ºå®šã‚¿ãƒ– */}
      <div className="flex border-b bg-white flex-shrink-0">
        <button
          onClick={() => setActiveTab('agents')}
          className={`px-6 py-3 font-medium ${
            activeTab === 'agents'
              ? 'border-b-2 border-blue-600 text-blue-600'
              : 'text-gray-600 hover:text-gray-800'
          }`}
        >
          ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç®¡ç†
        </button>
        <button
          onClick={() => setActiveTab('changes')}
          className={`px-6 py-3 font-medium ${
            activeTab === 'changes'
              ? 'border-b-2 border-blue-600 text-blue-600'
              : 'text-gray-600 hover:text-gray-800'
          }`}
        >
          å¤‰æ›´ä¸€è¦§
          {changes.filter(c => c.status === 'pending').length > 0 && (
            <span className="ml-2 px-2 py-1 bg-yellow-500 text-white text-xs rounded-full">
              {changes.filter(c => c.status === 'pending').length}
            </span>
          )}
        </button>
      </div>

      {/* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ - ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãªã—ã€å„ã‚¿ãƒ–ã§ç‹¬è‡ªã«ç®¡ç† */}
      <main className="flex-1 min-h-0">
        {activeTab === 'agents' ? (
          <AgentManager
            agents={agents}
            agentOutputs={agentOutputs}
            onStartAgent={handleStartAgent}
            onStopAgent={handleStopAgent}
            onRestartAgent={handleRestartAgent}
            onDeleteAgent={handleDeleteAgent}
            onExecuteCommand={handleExecuteCommand}
            onSendMessage={handleSendMessage}
            commandOutputs={commandOutputs}
          />
        ) : (
          <div className="h-full overflow-auto bg-gray-900">
            <div className="container mx-auto p-4">
              <div className="bg-[#0d1117] rounded-lg shadow-md border border-gray-700 p-6">
                <h2 className="text-xl font-bold mb-4 text-gray-100">ğŸ“ å¤‰æ›´ææ¡ˆä¸€è¦§</h2>
                <ChangeList
                  changes={changes}
                  onAccept={acceptChange}
                  onDecline={declineChange}
                  onInstruction={sendInstruction}
                />
              </div>
            </div>
          </div>
        )}
      </main>

      {/* ç·¨é›†æ¨©é™ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      {editPermissionRequest && (
        <EditPermissionModal
          isOpen={true}
          onClose={() => setEditPermissionRequest(null)}
          onApprove={async () => {
            console.log('Approved edit for:', editPermissionRequest.filePath);
            try {
              await apiClient.approveEdit(editPermissionRequest.agentId, editPermissionRequest.toolUseId);
              console.log('Edit approval sent to server');
            } catch (error) {
              console.error('Failed to send edit approval:', error);
              alert('ç·¨é›†æ‰¿èªã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå†èµ·å‹•ã•ã‚ŒãŸå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚');
            }
            setEditPermissionRequest(null);
          }}
          onReject={async () => {
            console.log('Rejected edit for:', editPermissionRequest.filePath);
            try {
              await apiClient.rejectEdit(editPermissionRequest.agentId, editPermissionRequest.toolUseId);
              console.log('Edit rejection sent to server');
            } catch (error) {
              console.error('Failed to send edit rejection:', error);
            }
            setEditPermissionRequest(null);
          }}
          filePath={editPermissionRequest.filePath}
          oldString={editPermissionRequest.oldString}
          newString={editPermissionRequest.newString}
        />
      )}
    </div>
  );
}

export default App;
